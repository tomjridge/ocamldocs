<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bucket_intf (kv_hash.Kv_hash__.Bucket_intf)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">kv_hash</a> &#x00BB; <a href="../index.html">Kv_hash__</a> &#x00BB; Bucket_intf</nav><h1>Module <code>Kv_hash__.Bucket_intf</code></h1></header><aside><p>Main interface types for bucket</p><p>A bucket is (abstractly) a small set of (key,value) pairs. In fact, keys and values are ints, but we stick with the use of &quot;key&quot; and &quot;value&quot;.</p><p>A bucket is represented concretely by an array of size sz_b bytes. The size sz_b is chosen such that it is equal to the page size of the OS, typically 4096 bytes (say, P=4096). On a 64bit machine, we can store 4096/8 = 512 ints in such an array.</p><p>Why choose the size according to P? We hope that P-aligned writes of size P are handled atomically by the OS, filesystem and storage device. We write buckets to storage in their entirety, at a P-aligned address in a file. We are aware that the OS may re-order the bucket writes. However, for correctness we only rely on the atomicity of bucket writes, not their relative ordering when they hit storage. After a sequence of bucket updates (following a large batch operation, say), we issue a final sync to the backing file. If we crash before the sync, at least the buckets are internally consistent and (per bucket) represent either the old state or the new state.</p><p>The keys in a bucket are typically all in some sub-range of the key space (in this case, there is some small range l &lt;= k &lt; h such that keys k lie within this range). Keys are assumed to be roughly uniformly distributed (so, the keys are actually hash values from some reasonable hash function). For a given bucket, the sub-range is not represented within the bucket itself, but rather, in some external structure (the partition).</p><p>The exact details of the layout of a bucket shouldn't matter too much. However, for the interested reader: there are two areas, the sorted area and the unsorted area. New kvs are added to the unsorted area. When this is full, the unsorted kvs are merged with the sorted kvs. Searching for a key proceeds first to scan the unsorted area, then the sorted area (using interpolation search for the sorted area). The idea of this design is to make insertion of a new kv fast on average, whilst also keeping most of the keys sorted (to allow quick search). The exact size of the unsorted area and the sorted area is probably best determined by experiment.</p><p>In order to implement this approach, we need to track (within the bucket) the length of the sorted region and the length of the unsorted region. This requires two ints. So we have 510 ints available for the sorted and unsorted kvs. Since a kv is a pair of ints, we can store 255 kvs in each bucket (at most). Currently we choose (rather arbitrarily) to store max 10 unsorted, and 245 sorted kvs in each bucket.</p></aside><div class="spec module-type" id="module-type-BUCKET_CONFIG"><a href="#module-type-BUCKET_CONFIG" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-BUCKET_CONFIG/index.html">BUCKET_CONFIG</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec type" id="type-exported_bucket"><a href="#type-exported_bucket" class="anchor"></a><code><span class="keyword">type</span> exported_bucket</code><code> = </code><code>{</code><table class="record"><tr id="type-exported_bucket.sorted" class="anchored"><td class="def field"><a href="#type-exported_bucket.sorted" class="anchor"></a><code>sorted : <span><span>(int * int)</span> list</span>;</code></td></tr><tr id="type-exported_bucket.unsorted" class="anchored"><td class="def field"><a href="#type-exported_bucket.unsorted" class="anchor"></a><code>unsorted : <span><span>(int * int)</span> list</span>;</code></td></tr></table><code>}</code></dt></dl><div><div class="spec include"><div class="doc"><dl><dt class="spec value" id="val-exported_bucket_of_sexp"><a href="#val-exported_bucket_of_sexp" class="anchor"></a><code><span class="keyword">val</span> exported_bucket_of_sexp : Ppx_sexp_conv_lib.Sexp.t <span>&#45;&gt;</span> <a href="index.html#type-exported_bucket">exported_bucket</a></code></dt><dt class="spec value" id="val-sexp_of_exported_bucket"><a href="#val-sexp_of_exported_bucket" class="anchor"></a><code><span class="keyword">val</span> sexp_of_exported_bucket : <a href="index.html#type-exported_bucket">exported_bucket</a> <span>&#45;&gt;</span> Ppx_sexp_conv_lib.Sexp.t</code></dt></dl></div></div></div></details></div></div></div><div class="spec module-type" id="module-type-BUCKET"><a href="#module-type-BUCKET" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-BUCKET/index.html">BUCKET</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>