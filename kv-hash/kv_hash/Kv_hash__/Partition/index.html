<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Partition (kv_hash.Kv_hash__.Partition)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">kv_hash</a> &#x00BB; <a href="../index.html">Kv_hash__</a> &#x00BB; Partition</nav><h1>Module <code>Kv_hash__.Partition</code></h1></header><aside><p>Top-level bucket partition, implemented using Jane St. Map</p><p>Given that we want to store (key,value) pairs, a partition is a way to map a key to a particular bucket, where we store the corresponding (key,value).</p><p>We assume that the keys are roughly uniformly distributed. (In our use case, they are hashes generated by some &quot;good&quot; hash function.)</p><p>We assume the key space is a linear order (in fact, our usecase has keys as ints... actually hashes). A partition is then (finitely represented) total map from key to bucket.</p><p>How do we implement this? Each bucket covers a range l_i &lt;= _ &lt; h_i. The ranges are mutually disjoint and cover the key space. So, <code>h_i = l_{i+1} say</code>. The partition contains a map from each l_i to a bucket identifier. Given a particular key k, we find the l_i which is just &lt;= k (i.e., it is &lt;= k, and is the largest such l) and look up the appropriate bucket identifier. This can be done efficiently using a map based on binary search trees. The standard library doesn't support this operation, but Jane St. map library does.</p><p>The lowest key (min_key) is 0 in our use case. Every partition explicitly contains at least a mapping for min_key.</p><p>Sometimes a bucket becomes full. In this case, we split the bucket into two new buckets (half the kvs in one, half in another), and split the old range l_i &lt;= _ &lt; h_i into two new ranges, corresponding to the two new buckets.</p><p>Terminology:</p><ul><li>partition: a total map from key to bucket identifier; each bucket corresponds to a subrange of the keyspace; these ranges are disjoint and cover the keyspace</li></ul><ul><li>bucket: a collection of kvs for a particular subrange of the space</li></ul><p>NOTE In our use case keys are ints from 0 to Int.max_int inclusive. This means we miss out on using negative integers.</p><p>FIXME distinguish offsets (and lengths) measured in ints <code>{off_i}</code> from offsets measured in bytes <code>{off_b}</code></p></aside><div class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-Make_1"><a href="#module-Make_1" class="anchor"></a><code><span class="keyword">module</span> <a href="Make_1/index.html">Make_1</a> : <span class="keyword">functor</span> (<a href="Make_1/argument-1-S/index.html">S</a> : <a href="index.html#module-type-S">S</a>) <span>&#45;&gt;</span> <a href="../../Kv_hash/Partition_intf/index.html#module-type-PURE_PARTITION">Kv_hash.Partition_intf.PURE_PARTITION</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Make_1/index.html#type-k">k</a> = <a href="Make_1/argument-1-S/index.html#type-k">S.k</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Make_1/index.html#type-r">r</a> = <a href="Make_1/argument-1-S/index.html#type-r">S.r</a></code></dt><dd><p>Pure partitions</p></dd></dl><dl><dt class="spec module" id="module-Make_2"><a href="#module-Make_2" class="anchor"></a><code><span class="keyword">module</span> <a href="Make_2/index.html">Make_2</a> : <span class="keyword">functor</span> (<a href="Make_2/argument-1-S/index.html">S</a> : <a href="index.html#module-type-S">S</a>) <span>&#45;&gt;</span> <a href="../../Kv_hash/Partition_intf/index.html#module-type-PARTITION">Kv_hash.Partition_intf.PARTITION</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Make_2/index.html#type-k">k</a> = <a href="Make_2/argument-1-S/index.html#type-k">S.k</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Make_2/index.html#type-r">r</a> = <a href="Make_2/argument-1-S/index.html#type-r">S.r</a></code></dt><dd><p>Mutable partitions, with split hook</p></dd></dl><div class="spec module" id="module-Make_partition"><a href="#module-Make_partition" class="anchor"></a><code><span class="keyword">module</span> Make_partition = <a href="index.html#module-Make_2">Make_2</a></code></div><dl><dt class="spec module" id="module-Partition_ii"><a href="#module-Partition_ii" class="anchor"></a><code><span class="keyword">module</span> <a href="Partition_ii/index.html">Partition_ii</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Default partition instance, mutable, k=int, r=int</p></dd></dl></div></body></html>