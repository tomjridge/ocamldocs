<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Freelist_intf (kv_hash.Kv_hash__.Freelist_intf)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">kv_hash</a> &#x00BB; <a href="../index.html">Kv_hash__</a> &#x00BB; Freelist_intf</nav><h1>Module <code>Kv_hash__.Freelist_intf</code></h1></header><aside><p>The freelist records which buckets are old (ie have been split into 2 new buckets) and can be recycled (ie reused in the NEXT merge).</p><p>NOTE on block recycling: Other processes (eg read only processes) should always start a lookup by checking whether they have the current partition. In addition they must always check for partition change just before returning any result; if the partition has changed since the process started the operation, the process must retry the operation; this ensures that recycled blocks are not misinterpreted leading to incorrect results.</p><p>Alternatively, if we can ensure that any other process can execute a single operation in less time than it takes from the start of one merge to the start of another, then we are (probably) safe, since no block will be recycled during that time (we recycle old blocks on the NEXT merge).</p></aside><div class="spec module-type" id="module-type-FREELIST"><a href="#module-type-FREELIST" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-FREELIST/index.html">FREELIST</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>