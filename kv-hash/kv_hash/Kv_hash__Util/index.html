<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Kv_hash__Util (kv_hash.Kv_hash__Util)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">kv_hash</a> &#x00BB; Kv_hash__Util</nav><h1>Module <code>Kv_hash__Util</code></h1></header><dl><dt class="spec value" id="val-iter_k"><a href="#val-iter_k" class="anchor"></a><code><span class="keyword">val</span> iter_k : <span>(<span>k:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>Essentially the Y combinator; useful for anonymous recursive functions. The k argument is the recursive callExample:</p><pre><code class="ml">iter_k (fun ~k n -&gt; 
    if n = 0 then 1 else n * k (n-1))</code></pre></dd></dl><dl><dt class="spec value" id="val-dest_Some"><a href="#val-dest_Some" class="anchor"></a><code><span class="keyword">val</span> dest_Some : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-trace"><a href="#val-trace" class="anchor"></a><code><span class="keyword">val</span> trace : <span>(unit <span>&#45;&gt;</span> string)</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-warn"><a href="#val-warn" class="anchor"></a><code><span class="keyword">val</span> warn : <span>(unit <span>&#45;&gt;</span> string)</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-debug"><a href="#val-debug" class="anchor"></a><code><span class="keyword">val</span> debug : <span>(unit <span>&#45;&gt;</span> string)</span> <span>&#45;&gt;</span> unit</code></dt></dl><dl><dt class="spec module" id="module-Make_comparator"><a href="#module-Make_comparator" class="anchor"></a><code><span class="keyword">module</span> <a href="Make_comparator/index.html">Make_comparator</a> : <span class="keyword">functor</span> (<a href="Make_comparator/argument-1-S/index.html">S</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>This builds a comparator for Jane St. Base.Map. Not sure this is the intended procedure.</p></dd></dl><dl><dt class="spec module" id="module-Interpolate"><a href="#module-Interpolate" class="anchor"></a><code><span class="keyword">module</span> <a href="Interpolate/index.html">Interpolate</a> : <span class="keyword">functor</span> (<a href="Interpolate/argument-1-S/index.html">S</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Interpolate once, then scan. ASSUMES we are using Stdlib.( &lt; &gt; =) etc</p></dd></dl><div class="spec module" id="module-Interpolate_ii"><a href="#module-Interpolate_ii" class="anchor"></a><code><span class="keyword">module</span> <a href="Interpolate_ii/index.html">Interpolate_ii</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Merge"><a href="#module-Merge" class="anchor"></a><code><span class="keyword">module</span> <a href="Merge/index.html">Merge</a> : <span class="keyword">functor</span> (<a href="Merge/argument-1-S/index.html">S</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val</span> merge : <span>ks1:<span>(int <span>&#45;&gt;</span> <span class="type-var">'k</span>)</span></span> <span>&#45;&gt;</span> <span>vs1:<span>(int <span>&#45;&gt;</span> <span class="type-var">'v</span>)</span></span> <span>&#45;&gt;</span> <span>len1:int</span> <span>&#45;&gt;</span> <span>ks2:<span>(int <span>&#45;&gt;</span> <span class="type-var">'k</span>)</span></span> <span>&#45;&gt;</span> <span>vs2:<span>(int <span>&#45;&gt;</span> <span class="type-var">'v</span>)</span></span> <span>&#45;&gt;</span> <span>len2:int</span> <span>&#45;&gt;</span> <span>set:<span>(int <span>&#45;&gt;</span> <span class="type-var">'k</span> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> int</code></dt></dl><div class="spec module" id="module-Mmap"><a href="#module-Mmap" class="anchor"></a><code><span class="keyword">module</span> Mmap = Tjr_mmap.Mmap</code></div><dl><dt class="spec value" id="val-write_increasing"><a href="#val-write_increasing" class="anchor"></a><code><span class="keyword">val</span> write_increasing : <span>bin_write_v:<span><span class="type-var">'a</span> Bin_prot.Write.writer</span></span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> <span>mmap:<span><span>(char, Stdlib.Bigarray.int8_unsigned_elt)</span> <a href="index.html#module-Mmap">Mmap</a>.t</span></span> <span>&#45;&gt;</span> <span>off:int</span> <span>&#45;&gt;</span> <span>v:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> Bin_prot.Common.pos</code></dt><dd><p>Write to mmap using a bin_writer; allocate len space initially; if not enough space, increase the buffer size and try again.</p></dd></dl><dl><dt class="spec value" id="val-read_increasing"><a href="#val-read_increasing" class="anchor"></a><code><span class="keyword">val</span> read_increasing : <span>bin_read_v:<span><span class="type-var">'a</span> Bin_prot.Read.reader</span></span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> <span>mmap:<span><span>(char, Stdlib.Bigarray.int8_unsigned_elt)</span> <a href="index.html#module-Mmap">Mmap</a>.t</span></span> <span>&#45;&gt;</span> <span>off:int</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt></dl><dl><dt class="spec type" id="type-char_bigarray"><a href="#type-char_bigarray" class="anchor"></a><code><span class="keyword">type</span> char_bigarray</code><code> = <span><span>(char, Stdlib.Bigarray.int8_unsigned_elt, Stdlib.Bigarray.c_layout)</span> Stdlib.Bigarray.Array1.t</span></code></dt><dt class="spec type" id="type-int_bigarray"><a href="#type-int_bigarray" class="anchor"></a><code><span class="keyword">type</span> int_bigarray</code><code> = <span><span>(int, Stdlib.Bigarray.int_elt, Stdlib.Bigarray.c_layout)</span> Stdlib.Bigarray.Array1.t</span></code></dt><dt class="spec type" id="type-int_ba_t"><a href="#type-int_ba_t" class="anchor"></a><code><span class="keyword">type</span> int_ba_t</code><code> = <span><span>(int, Stdlib.Bigarray.int_elt, Stdlib.Bigarray.c_layout)</span> Stdlib.Bigarray.Array1.t</span></code></dt><dt class="spec type" id="type-kind"><a href="#type-kind" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) kind</span></code><code> = <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> Stdlib.Bigarray.kind</span></code></dt><dd><p>The kind of the mmap'ed array; see Bigarray.kind</p></dd></dl><dl><dt class="spec value" id="val-char_kind"><a href="#val-char_kind" class="anchor"></a><code><span class="keyword">val</span> char_kind : <span><span>(char, Stdlib.Bigarray.int8_unsigned_elt)</span> <a href="index.html#type-kind">kind</a></span></code></dt><dt class="spec value" id="val-int_kind"><a href="#val-int_kind" class="anchor"></a><code><span class="keyword">val</span> int_kind : <span><span>(int, Stdlib.Bigarray.int_elt)</span> <a href="index.html#type-kind">kind</a></span></code></dt><dt class="spec value" id="val-log_fn"><a href="#val-log_fn" class="anchor"></a><code><span class="keyword">val</span> log_fn : int <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-part_fn"><a href="#val-part_fn" class="anchor"></a><code><span class="keyword">val</span> part_fn : int <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-freelist_fn"><a href="#val-freelist_fn" class="anchor"></a><code><span class="keyword">val</span> freelist_fn : int <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-coerce_bigarray1"><a href="#val-coerce_bigarray1" class="anchor"></a><code><span class="keyword">val</span> coerce_bigarray1 : <span><span class="type-var">'t1</span> Ctypes.typ</span> <span>&#45;&gt;</span> <span><span class="type-var">'t2</span> Ctypes.typ</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'t2</span>, <span class="type-var">'a</span>)</span> Bigarray_compat.kind</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'t1</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> Bigarray_compat.Array1.t</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'t2</span>, <span class="type-var">'a</span>, Bigarray_compat.c_layout)</span> Bigarray_compat.Array1.t</span></code></dt><dt class="spec value" id="val-write_int_ba"><a href="#val-write_int_ba" class="anchor"></a><code><span class="keyword">val</span> write_int_ba : <span>fd:Core.Unix.File_descr.t</span> <span>&#45;&gt;</span> <span>off:int</span> <span>&#45;&gt;</span> <a href="index.html#type-int_ba_t">int_ba_t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-read_int_ba"><a href="#val-read_int_ba" class="anchor"></a><code><span class="keyword">val</span> read_int_ba : <span>blk_sz:Core_kernel__.Import.int</span> <span>&#45;&gt;</span> <span>fd:Core.Unix.File_descr.t</span> <span>&#45;&gt;</span> <span>off:int</span> <span>&#45;&gt;</span> <span><span>(int, Stdlib.Bigarray.int_elt, Bigarray_compat.c_layout)</span> Bigarray_compat.Array1.t</span></code></dt><dt class="spec value" id="val-sorted_int_ba"><a href="#val-sorted_int_ba" class="anchor"></a><code><span class="keyword">val</span> sorted_int_ba : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> Stdlib.Bigarray.Array1.t</span> <span>&#45;&gt;</span> bool</code></dt></dl><div class="spec module" id="module-Map_i"><a href="#module-Map_i" class="anchor"></a><code><span class="keyword">module</span> <a href="Map_i/index.html">Map_i</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-Sexp_trace"><a href="#module-Sexp_trace" class="anchor"></a><code><span class="keyword">module</span> <a href="Sexp_trace/index.html">Sexp_trace</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>NOTE taken from kv-lite/trace.ml</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Kv_hash__/Config/index.html#module-Consts">Kv_hash__.Config.Consts</a></code></span></summary><dl><dt class="spec value" id="val-const_4GB"><a href="#val-const_4GB" class="anchor"></a><code><span class="keyword">val</span> const_4GB : int</code></dt><dt class="spec value" id="val-const_1GiB"><a href="#val-const_1GiB" class="anchor"></a><code><span class="keyword">val</span> const_1GiB : int</code></dt><dt class="spec value" id="val-const_1k"><a href="#val-const_1k" class="anchor"></a><code><span class="keyword">val</span> const_1k : int</code></dt><dt class="spec value" id="val-const_1M"><a href="#val-const_1M" class="anchor"></a><code><span class="keyword">val</span> const_1M : int</code></dt><dt class="spec value" id="val-const_1MiB"><a href="#val-const_1MiB" class="anchor"></a><code><span class="keyword">val</span> const_1MiB : int</code></dt></dl></details></div></div></div><dl><dt class="spec module" id="module-Lru_ss"><a href="#module-Lru_ss" class="anchor"></a><code><span class="keyword">module</span> <a href="Lru_ss/index.html">Lru_ss</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A mutable Lru for string-&gt;string map; at the moment this does not record negative information (this key is not present) but perhaps it should FIXME</p></dd></dl><dl><dt class="spec value" id="val-perm0"><a href="#val-perm0" class="anchor"></a><code><span class="keyword">val</span> perm0 : int</code></dt><dd><p>default file perm: u+rw, g+r</p></dd></dl><dl><dt class="spec value" id="val-int_sz_bytes"><a href="#val-int_sz_bytes" class="anchor"></a><code><span class="keyword">val</span> int_sz_bytes : int</code></dt></dl></div></body></html>