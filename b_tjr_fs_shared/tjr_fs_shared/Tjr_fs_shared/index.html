<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Tjr_fs_shared (tjr_fs_shared.Tjr_fs_shared)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">tjr_fs_shared</a> &#x00BB; Tjr_fs_shared</nav><h1>Module <code>Tjr_fs_shared</code></h1><p>Common types and defns for file system work.</p><p>A collection of the main types provided by this library.</p><nav class="toc"><ul><li><a href="#int-like-types">Int-like types</a></li><li><a href="#buffers">Buffers</a></li><li><a href="#block-identifiers">Block identifiers</a></li><li><a href="#blocks">Blocks</a></li><li><a href="#block-devices">Block devices</a></li><li><a href="#block-allocation">Block allocation</a></li><li><a href="#note-on-sync-and-the-blk-device-layer">Note on sync and the blk device layer</a></li><li><a href="#kv-ops">Kv ops</a></li><li><a href="#small-strings,-leq-256-bytes">Small strings, leq 256 bytes</a></li><li><a href="#write-back-cache">Write back cache</a></li><li><a href="#marshalling">Marshalling</a></li><li><a href="#marshalling-with-bin-prot">Marshalling with bin-prot</a></li><li><a href="#standard-example-types-and-defns">Standard example types and defns</a></li><li><a href="#testing">Testing</a></li><li><a href="#log">Log</a></li><li><a href="#runtime-config-support">Runtime config support</a></li></ul></nav></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Tjr_fs_shared__/index.html#module-Summary">Tjr_fs_shared__.Summary</a></code></span></summary><aside><p>Summary of main types</p></aside><aside><pre><code class="ml">  type ('blk_id,'t) blk_allocator_ops = {
    blk_alloc : unit -&gt; ('blk_id,'t) m; 
    blk_free  : 'blk_id -&gt; (unit,'t) m;
  }

type ('blk_id,'blk,'t,'fd) blk_dev_impl = &lt;
  add_debug : 
    ('blk_id,'blk,'t)blk_dev_ops -&gt; 
    ('blk_id,'blk,'t)blk_dev_ops;

  add_profiling: 
    ('blk_id,'blk,'t)blk_dev_ops -&gt; 
    ('blk_id,'blk,'t)blk_dev_ops;

  with_ : blk_sz:blk_sz -&gt; &lt;
      from_fd: 'fd -&gt; 
        &lt;
          blk_dev_ops : ('blk_id,'blk,'t)blk_dev_ops;
          fd          : 'fd;
          sync        : unit -&gt; (unit,'t)m;
          close       : unit -&gt; (unit,'t)m;
        &gt;;
    &gt;
&gt;    

  type ('blk_id,'blk,'t) blk_dev_ops = {
    blk_sz     : blk_sz; 
    write      : blk_id:'blk_id -&gt; blk:'blk -&gt; (unit,'t) m;
    read       : blk_id:'blk_id -&gt; ('blk,'t) m;
    write_many : ('blk_id*'blk)list -&gt; (unit,'t) m  (* FIXME may want to make this a seq? *)
  }

  type ('blk,'buf) blk_ops = {
    blk_sz: blk_sz;
    blk_to_buf: 'blk -&gt; 'buf;
    buf_to_blk: 'buf -&gt; 'blk;
  }

type 'buf buf_ops = {
  buf_create         : int -&gt; 'buf;
  buf_length         : 'buf -&gt; int;

  buf_to_string      : src:'buf -&gt; off:offset -&gt; len:len -&gt; string; 
  to_string          : 'buf -&gt; string;
  of_string          : string -&gt; 'buf;
  of_bytes           : bytes -&gt; 'buf;

  blit               : src:'buf   -&gt; src_off:offset -&gt; src_len:len -&gt; dst:'buf -&gt; dst_off:offset -&gt; 'buf;
  blit_bytes_to_buf  : src:bytes  -&gt; src_off:offset -&gt; src_len:len -&gt; dst:'buf -&gt; dst_off:offset -&gt; 'buf;
  blit_string_to_buf : src:string -&gt; src_off:offset -&gt; src_len:len -&gt; dst:'buf -&gt; dst_off:offset -&gt; 'buf;
}

type ('r,'blk,'buf,'t) shared_ctxt = {
  r_cmp      : 'r -&gt; 'r -&gt; int;
  r_size     :int;
  buf_ops    :'buf buf_ops;
  monad_ops  : 't monad_ops;
  async      : 't async;
  event_ops  : 't event_ops;
  blk_ops    : ('blk,'buf) blk_ops;
  blk_sz     : blk_sz;
  buf_to_blk : 'buf -&gt; 'blk;
  blk_to_buf : 'blk -&gt; 'buf;
  buf_create : unit -&gt; 'buf;
}</code></pre></aside></details></div></div></div><section><header><h3 id="int-like-types"><a href="#int-like-types" class="anchor"></a>Int-like types</h3></header><dl><dt class="spec module" id="module-Int_like"><a href="#module-Int_like" class="anchor"></a><code><span class="keyword">module</span> <a href="Int_like/index.html">Int_like</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Int-like types with unboxed record wrappers, for documentation purposes</p></dd></dl></section><section><header><h3 id="buffers"><a href="#buffers" class="anchor"></a>Buffers</h3></header><dl><dt class="spec module" id="module-Buf_ops"><a href="#module-Buf_ops" class="anchor"></a><code><span class="keyword">module</span> <a href="Buf_ops/index.html">Buf_ops</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Buffer operations including blit, moved from Tjr_btree.</p></dd></dl><dl><dt class="spec type" id="type-buf_ops"><a href="#type-buf_ops" class="anchor"></a><code><span class="keyword">type</span> <span>'buf buf_ops</span></code><code> = <span><span class="type-var">'buf</span> <a href="Buf_ops/index.html#type-buf_ops">Buf_ops.buf_ops</a></span></code></dt></dl><dl><dt class="spec value" id="val-chr0"><a href="#val-chr0" class="anchor"></a><code><span class="keyword">val</span> chr0 : char</code></dt></dl><aside><p>NOTE lwt uses bytes eg for pread and pwrite; FUSE prefers bigarray; so we have two main buffer implementations, bytes and bigarray</p><p>$(ABBREV(&quot;ba = bigarray&quot;))</p></aside><dl><dt class="spec type" id="type-ba_buf"><a href="#type-ba_buf" class="anchor"></a><code><span class="keyword">type</span> ba_buf</code><code> = <a href="Buf_ops/index.html#type-ba_buf">Buf_ops.ba_buf</a></code></dt><dt class="spec type" id="type-ba_buf_ops"><a href="#type-ba_buf_ops" class="anchor"></a><code><span class="keyword">type</span> ba_buf_ops</code><code> = <a href="Buf_ops/index.html#type-ba_buf_ops">Buf_ops.ba_buf_ops</a></code></dt></dl><dl><dt class="spec value" id="val-ba_buf_ops"><a href="#val-ba_buf_ops" class="anchor"></a><code><span class="keyword">val</span> ba_buf_ops : <span>Bigstring.t <a href="Buf_ops/index.html#type-buf_ops">Buf_ops.buf_ops</a></span></code></dt><dt class="spec value" id="val-by_buf_ops"><a href="#val-by_buf_ops" class="anchor"></a><code><span class="keyword">val</span> by_buf_ops : <span>bytes <a href="Buf_ops/index.html#type-buf_ops">Buf_ops.buf_ops</a></span></code></dt></dl></section><section><header><h3 id="block-identifiers"><a href="#block-identifiers" class="anchor"></a>Block identifiers</h3></header><dl><dt class="spec module" id="module-Blk_intf"><a href="#module-Blk_intf" class="anchor"></a><code><span class="keyword">module</span> <a href="Blk_intf/index.html">Blk_intf</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Blk-related interfaces</p></dd></dl><div class="spec module" id="module-Blk_id_as_int"><a href="#module-Blk_id_as_int" class="anchor"></a><code><span class="keyword">module</span> Blk_id_as_int = <a href="Blk_intf/index.html#module-Blk_id_as_int">Blk_intf.Blk_id_as_int</a></code></div></section><section><header><h3 id="blocks"><a href="#blocks" class="anchor"></a>Blocks</h3></header><div class="spec module" id="module-Blk_sz"><a href="#module-Blk_sz" class="anchor"></a><code><span class="keyword">module</span> Blk_sz = <a href="Blk_intf/index.html#module-Blk_sz">Blk_intf.Blk_sz</a></code></div><dl><dt class="spec type" id="type-blk_sz"><a href="#type-blk_sz" class="anchor"></a><code><span class="keyword">type</span> blk_sz</code><code> = <a href="../Tjr_fs_shared__Blk_intf/Blk_sz/index.html#type-blk_sz">Blk_sz.blk_sz</a></code></dt></dl><dl><dt class="spec value" id="val-blk_sz_4096"><a href="#val-blk_sz_4096" class="anchor"></a><code><span class="keyword">val</span> blk_sz_4096 : <a href="../Tjr_fs_shared__Blk_intf/Blk_sz/index.html#type-blk_sz">Blk_sz.blk_sz</a></code></dt></dl><div class="spec module" id="module-Blk_ops"><a href="#module-Blk_ops" class="anchor"></a><code><span class="keyword">module</span> Blk_ops = <a href="Blk_intf/index.html#module-Blk_ops">Blk_intf.Blk_ops</a></code></div><dl><dt class="spec type" id="type-blk_ops"><a href="#type-blk_ops" class="anchor"></a><code><span class="keyword">type</span> <span>('blk, 'buf) blk_ops</span></code><code> = <span><span>(<span class="type-var">'blk</span>, <span class="type-var">'buf</span>)</span> <a href="../Tjr_fs_shared__Blk_intf/Blk_ops/index.html#type-blk_ops">Blk_ops.blk_ops</a></span></code></dt></dl><dl><dt class="spec value" id="val-blk_ops"><a href="#val-blk_ops" class="anchor"></a><code><span class="keyword">val</span> blk_ops : &lt; ba_ba_4096 : <span><span>(<a href="Buf_ops/index.html#type-ba_buf">Buf_ops.ba_buf</a>, <a href="Buf_ops/index.html#type-ba_buf">Buf_ops.ba_buf</a>)</span> <a href="Blk_intf/index.html#type-blk_ops">Blk_intf.blk_ops</a></span>; &gt;</code></dt></dl></section><section><header><h3 id="block-devices"><a href="#block-devices" class="anchor"></a>Block devices</h3></header><div class="spec module" id="module-Blk_dev_ops"><a href="#module-Blk_dev_ops" class="anchor"></a><code><span class="keyword">module</span> Blk_dev_ops = <a href="Blk_intf/index.html#module-Blk_dev_ops">Blk_intf.Blk_dev_ops</a></code></div><dl><dt class="spec type" id="type-blk_dev_ops"><a href="#type-blk_dev_ops" class="anchor"></a><code><span class="keyword">type</span> <span>('blk_id, 'blk, 't) blk_dev_ops</span></code><code> = <span><span>(<span class="type-var">'blk_id</span>, <span class="type-var">'blk</span>, <span class="type-var">'t</span>)</span> <a href="../Tjr_fs_shared__Blk_intf/Blk_dev_ops/index.html#type-blk_dev_ops">Blk_dev_ops.blk_dev_ops</a></span></code><code> = </code><code>{</code><table class="record"><tr id="type-blk_dev_ops.blk_sz" class="anchored"><td class="def field"><a href="#type-blk_dev_ops.blk_sz" class="anchor"></a><code>blk_sz : <a href="index.html#type-blk_sz">blk_sz</a>;</code></td></tr><tr id="type-blk_dev_ops.write" class="anchored"><td class="def field"><a href="#type-blk_dev_ops.write" class="anchor"></a><code>write : <span>blk_id:<span class="type-var">'blk_id</span></span> <span>&#45;&gt;</span> <span>blk:<span class="type-var">'blk</span></span> <span>&#45;&gt;</span> <span><span>(unit, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr><tr id="type-blk_dev_ops.read" class="anchored"><td class="def field"><a href="#type-blk_dev_ops.read" class="anchor"></a><code>read : <span>blk_id:<span class="type-var">'blk_id</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'blk</span>, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr><tr id="type-blk_dev_ops.write_many" class="anchored"><td class="def field"><a href="#type-blk_dev_ops.write_many" class="anchor"></a><code>write_many : <span><span>(<span class="type-var">'blk_id</span> * <span class="type-var">'blk</span>)</span> list</span> <span>&#45;&gt;</span> <span><span>(unit, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-blk_devs"><a href="#val-blk_devs" class="anchor"></a><code><span class="keyword">val</span> blk_devs : &lt; in_mem : <span>monad_ops:<span><span class="type-var">'a</span> Tjr_monad.monad_ops</span></span> <span>&#45;&gt;</span> <span>blk_sz:<a href="Blk_intf/index.html#type-blk_sz">Blk_intf.blk_sz</a></span> <span>&#45;&gt;</span> <span>with_state:<span><span>(<span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> Tjr_lib.Tjr_map.With_stdcmp.stdmap</span>, <span class="type-var">'a</span>)</span> Tjr_monad.with_state</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'a</span>)</span> <a href="Blk_intf/index.html#type-blk_dev_ops">Blk_intf.blk_dev_ops</a></span>; lwt : <span><span>(<a href="../Tjr_fs_shared__Blk_intf/Blk_id_as_int/index.html#type-blk_id">Blk_intf.Blk_id_as_int.blk_id</a>, Bigstring.t, Tjr_monad.With_lwt.lwt, Lwt_unix.file_descr)</span> <a href="Blk_intf/index.html#type-blk_dev_impl">Blk_intf.blk_dev_impl</a></span>; lwt_open_file : <span>fn:string</span> <span>&#45;&gt;</span> <span>create:bool</span> <span>&#45;&gt;</span> <span>trunc:bool</span> <span>&#45;&gt;</span> <span><span>(&lt; blk_dev_ops : <span><span>(<a href="../Tjr_fs_shared__Blk_intf/Blk_id_as_int/index.html#type-blk_id">Blk_intf.Blk_id_as_int.blk_id</a>, Bigstring.t, Tjr_monad.With_lwt.lwt)</span> <a href="Blk_intf/index.html#type-blk_dev_ops">Blk_intf.blk_dev_ops</a></span>; close : unit <span>&#45;&gt;</span> <span><span>(unit, Tjr_monad.With_lwt.lwt)</span> Tjr_monad.m</span>; fd : Lwt_unix.file_descr; sync : unit <span>&#45;&gt;</span> <span><span>(unit, Tjr_monad.With_lwt.lwt)</span> Tjr_monad.m</span>; &gt;, Tjr_monad.With_lwt.lwt)</span> Tjr_monad.m</span>; &gt;</code></dt></dl></section><section><header><h3 id="block-allocation"><a href="#block-allocation" class="anchor"></a>Block allocation</h3></header><div class="spec module" id="module-Blk_allocator_ops"><a href="#module-Blk_allocator_ops" class="anchor"></a><code><span class="keyword">module</span> Blk_allocator_ops = <a href="Blk_intf/index.html#module-Blk_allocator_ops">Blk_intf.Blk_allocator_ops</a></code></div><dl><dt class="spec type" id="type-blk_allocator_ops"><a href="#type-blk_allocator_ops" class="anchor"></a><code><span class="keyword">type</span> <span>('blk_id, 't) blk_allocator_ops</span></code><code> = <span><span>(<span class="type-var">'blk_id</span>, <span class="type-var">'t</span>)</span> <a href="../Tjr_fs_shared__Blk_intf/Blk_allocator_ops/index.html#type-blk_allocator_ops">Blk_allocator_ops.blk_allocator_ops</a></span></code><code> = </code><code>{</code><table class="record"><tr id="type-blk_allocator_ops.blk_alloc" class="anchored"><td class="def field"><a href="#type-blk_allocator_ops.blk_alloc" class="anchor"></a><code>blk_alloc : unit <span>&#45;&gt;</span> <span><span>(<span class="type-var">'blk_id</span>, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr><tr id="type-blk_allocator_ops.blk_free" class="anchored"><td class="def field"><a href="#type-blk_allocator_ops.blk_free" class="anchor"></a><code>blk_free : <span class="type-var">'blk_id</span> <span>&#45;&gt;</span> <span><span>(unit, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr></table><code>}</code></dt></dl></section><section><header><h3 id="note-on-sync-and-the-blk-device-layer"><a href="#note-on-sync-and-the-blk-device-layer" class="anchor"></a>Note on sync and the blk device layer</h3></header><aside><p>A traditional block device accepts (read and) write requests. Write requests can be reordered, although writes for a particular blk id will commit in order.</p><p>A barrier operation enforces that it is not the case that a request before the barrier is reordered with a request after the barrier.</p><p>A sync operation requests that all writes are actually made persistent.</p><p>Of course, many devices do not implement these things properly.</p><p>Newer interfaces, such as (variants of) TCQ and NVMe, are more complicated. Typically there are queues of operations. Barrier and flush commands can be per-queue. It may be possible to request notification for when some operation actually completes (say, when a write is made persistent). There is often a &quot;Forced Unit Access (FUA)&quot; mode, which attempts to avoid caching etc and just persist the write. It may also be possible to provide additional information about the &quot;priority&quot; of a write, or even a &quot;time out&quot; associated with a write (if it hasn't happened by this time, then don't perform the write at all).</p><p>Effectively, a queue operates like a traditional block device.</p><p>Traditional block devices are likely to be very slow; queue-based interfaces such as those used in NVMe, are likely to be a much better fit for ImpFS. Suppose we have a persistent object on which we call the &quot;sync&quot; method. Then a traditional blk layer may already have some cached writes related to that object. If the blk layer does not know the connection between these writes and the object, then a sync on the object must force a complete sync of the blk layer (including all writes to all objects) which is potentially very costly. If we assume a queue-based interface, then things are much better, because the sync can target a particular queue (and all writes for the object will be placed in that queue).</p><p>In ImpFS, each object is provided with an interface that appears like a traditional block device (with sync and possibly barrier operations). However, the real block layer is assumed to be queue based. Our current implementations of this on top of traditional block devices are very inefficient because we effectively have only one queue. However, we expect that porting the code to use a more advanced queue-based interface would give a much greater performance.</p><p>It is perhaps worth putting some effort into emulating the queue-based interface efficiently on top of a traditional block device. I'm not sure how this should best be achieved, or whether it would actually improve performance.</p></aside></section><section><header><h3 id="kv-ops"><a href="#kv-ops" class="anchor"></a>Kv ops</h3></header><dl><dt class="spec module" id="module-Kvop"><a href="#module-Kvop" class="anchor"></a><code><span class="keyword">module</span> <a href="Kvop/index.html">Kvop</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A concrete type for insert and delete operations. Don't open.</p></dd></dl><dl><dt class="spec type" id="type-kvop"><a href="#type-kvop" class="anchor"></a><code><span class="keyword">type</span> <span>('k, 'v) kvop</span></code><code> = <span><span>(<span class="type-var">'k</span>, <span class="type-var">'v</span>)</span> <a href="Kvop/index.html#type-kvop">Kvop.kvop</a></span></code></dt></dl><div class="spec module" id="module-Kvop_map"><a href="#module-Kvop_map" class="anchor"></a><code><span class="keyword">module</span> Kvop_map = <a href="Kvop/index.html#module-Kvop_map">Kvop.Kvop_map</a></code></div></section><section><header><h3 id="small-strings,-leq-256-bytes"><a href="#small-strings,-leq-256-bytes" class="anchor"></a>Small strings, leq 256 bytes</h3></header><dl><dt class="spec module" id="module-Str_256"><a href="#module-Str_256" class="anchor"></a><code><span class="keyword">module</span> <a href="Str_256/index.html">Str_256</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Strings with max length 256 bytes; safe to open</p></dd></dl><dl><dt class="spec type" id="type-str_256"><a href="#type-str_256" class="anchor"></a><code><span class="keyword">type</span> str_256</code><code> = <a href="Str_256/index.html#type-str_256">Str_256.str_256</a></code></dt></dl></section><section><header><h3 id="write-back-cache"><a href="#write-back-cache" class="anchor"></a>Write back cache</h3></header><div class="spec module" id="module-Write_back_cache_v1_DONT_USE"><a href="#module-Write_back_cache_v1_DONT_USE" class="anchor"></a><code><span class="keyword">module</span> Write_back_cache_v1_DONT_USE = <a href="index.html#module-Write_back_cache">Write_back_cache</a></code></div><div class="spec module" id="module-Write_back_cache_v2_DONT_USE"><a href="#module-Write_back_cache_v2_DONT_USE" class="anchor"></a><code><span class="keyword">module</span> Write_back_cache_v2_DONT_USE = <a href="../Tjr_fs_shared__/index.html#module-Write_back_cache_v2">Tjr_fs_shared__.Write_back_cache_v2</a></code></div><dl><dt class="spec module" id="module-Write_back_cache_v3"><a href="#module-Write_back_cache_v3" class="anchor"></a><code><span class="keyword">module</span> <a href="Write_back_cache_v3/index.html">Write_back_cache_v3</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A write-back cache; a wrapper around pqwy/lru.</p></dd></dl><div class="spec module" id="module-Write_back_cache"><a href="#module-Write_back_cache" class="anchor"></a><code><span class="keyword">module</span> Write_back_cache = <a href="index.html#module-Write_back_cache_v3">Write_back_cache_v3</a></code></div><dl><dt class="spec type" id="type-wbc_params"><a href="#type-wbc_params" class="anchor"></a><code><span class="keyword">type</span> wbc_params</code><code> = <a href="Write_back_cache_v3/index.html#type-wbc_params">Write_back_cache.wbc_params</a></code></dt><dt class="spec type" id="type-wbc_ops"><a href="#type-wbc_ops" class="anchor"></a><code><span class="keyword">type</span> <span>('k, 'v, 't) wbc_ops</span></code><code> = <span><span>(<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'t</span>)</span> <a href="Write_back_cache_v3/index.html#type-wbc_ops">Write_back_cache.wbc_ops</a></span></code></dt><dt class="spec type" id="type-wbc_ops_plus"><a href="#type-wbc_ops_plus" class="anchor"></a><code><span class="keyword">type</span> <span>('k, 'v, 't) wbc_ops_plus</span></code><code> = <span><span>(<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'t</span>)</span> <a href="Write_back_cache_v3/index.html#type-wbc_ops_plus">Write_back_cache.wbc_ops_plus</a></span></code></dt><dt class="spec type" id="type-wbc_factory"><a href="#type-wbc_factory" class="anchor"></a><code><span class="keyword">type</span> <span>('k, 'v, 't) wbc_factory</span></code><code> = <span><span>(<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'t</span>)</span> <a href="Write_back_cache_v3/index.html#type-wbc_factory">Write_back_cache.wbc_factory</a></span></code></dt></dl></section><section><header><h3 id="marshalling"><a href="#marshalling" class="anchor"></a>Marshalling</h3></header><aside><p>There are basically two types of marshalling one might consider. They differ in the behaviour when attempting to marshal to a point in a buffer where the remaining space is not sufficient. In the first &quot;max-size-based&quot; model, the marshaller knows the max size of an element, and the remaining space, and then can determine ahead of marshalling if the space is (potentially) not sufficient. In this case, the marshaller can abort early without attempting any modification of the buffer. However, it may be that the particular element would have actually fit the space, so the approach may be inefficient. Maybe the marshaller can calculate the marshalled size of each element (without actually performing the marshalling). As mentioned in the bin_prot documentation, this is rare because being able to calculate the marshalled size of an elt is often as difficult as trying to marshal the element (and failing when the space is insufficient). So if we assume the decision is based on the max-size, this approach may be inefficient. However, crucially, in the case that the marshalling is not attempted because of insufficient space, the buffer is unchanged.</p><p>This should be contrasted with the &quot;always-try-to-write&quot; approach, where the marshalling is attempted regardless of the available space. If an error occurs (lack of space), the marshalling is aborted. In this case, the buffer will almost certainly be altered from the write position onwards (because it is too costly to record what these bytes are and replace them on a failed marshal).</p><p>The B-tree datastructure arguably favours the &quot;max-size-based&quot; model, and so this is mostly the approach we take here.</p></aside><dl><dt class="spec module" id="module-Marshal_factory"><a href="#module-Marshal_factory" class="anchor"></a><code><span class="keyword">module</span> <a href="Marshal_factory/index.html">Marshal_factory</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Common marshallers</p></dd></dl><dl><dt class="spec type" id="type-mshlr"><a href="#type-mshlr" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'buf) mshlr</span></code><code> = <span><span>(<span class="type-var">'a</span>, <span class="type-var">'buf</span>)</span> <a href="Marshal_factory/index.html#type-mshlr">Marshal_factory.mshlr</a></span></code><code> = </code><code>{</code><table class="record"><tr id="type-mshlr.max_elt_sz" class="anchored"><td class="def field"><a href="#type-mshlr.max_elt_sz" class="anchor"></a><code>max_elt_sz : int;</code></td></tr><tr id="type-mshlr.mshl" class="anchored"><td class="def field"><a href="#type-mshlr.mshl" class="anchor"></a><code>mshl : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'buf</span> * int)</span> <span>&#45;&gt;</span> <span class="type-var">'buf</span> * int;</code></td></tr><tr id="type-mshlr.umshl" class="anchored"><td class="def field"><a href="#type-mshlr.umshl" class="anchor"></a><code>umshl : <span class="type-var">'buf</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> * int;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-kv_mshlr"><a href="#type-kv_mshlr" class="anchor"></a><code><span class="keyword">type</span> <span>('k, 'v, 'buf) kv_mshlr</span></code><code> = <span><span>(<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'buf</span>)</span> <a href="Marshal_factory/index.html#type-kv_mshlr">Marshal_factory.kv_mshlr</a></span></code><code> = </code><code>{</code><table class="record"><tr id="type-kv_mshlr.k_mshlr" class="anchored"><td class="def field"><a href="#type-kv_mshlr.k_mshlr" class="anchor"></a><code>k_mshlr : <span><span>(<span class="type-var">'k</span>, <span class="type-var">'buf</span>)</span> <a href="index.html#type-mshlr">mshlr</a></span>;</code></td></tr><tr id="type-kv_mshlr.v_mshlr" class="anchored"><td class="def field"><a href="#type-kv_mshlr.v_mshlr" class="anchor"></a><code>v_mshlr : <span><span>(<span class="type-var">'v</span>, <span class="type-var">'buf</span>)</span> <a href="index.html#type-mshlr">mshlr</a></span>;</code></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-mshlrs"><a href="#val-mshlrs" class="anchor"></a><code><span class="keyword">val</span> mshlrs : &lt; for_blk_id : <span><span>(<a href="../Tjr_fs_shared__Blk_intf/Blk_id_as_int/index.html#type-blk_id">Blk_intf.Blk_id_as_int.blk_id</a>, Bin_prot.Common.buf)</span> <a href="Marshal_factory/index.html#type-mshlr">Marshal_factory.mshlr</a></span>; for_blk_id_option : <span><span>(<span><a href="../Tjr_fs_shared__Blk_intf/Blk_id_as_int/index.html#type-blk_id">Blk_intf.Blk_id_as_int.blk_id</a> option</span>, Bin_prot.Common.buf)</span> <a href="Marshal_factory/index.html#type-mshlr">Marshal_factory.mshlr</a></span>; for_int : <span><span>(int, Bin_prot.Common.buf)</span> <a href="Marshal_factory/index.html#type-mshlr">Marshal_factory.mshlr</a></span>; for_int_option : <span><span>(<span>int option</span>, Bin_prot.Common.buf)</span> <a href="Marshal_factory/index.html#type-mshlr">Marshal_factory.mshlr</a></span>; for_kv : &lt; int_int : <span><span>(int, int, Bin_prot.Common.buf)</span> <a href="Marshal_factory/index.html#type-kv_mshlr">Marshal_factory.kv_mshlr</a></span>; s256_int : <span><span>(<a href="Str_256/index.html#type-str_256">Str_256.str_256</a>, int, Bin_prot.Common.buf)</span> <a href="Marshal_factory/index.html#type-kv_mshlr">Marshal_factory.kv_mshlr</a></span>; s256_s256 : <span><span>(<a href="Str_256/index.html#type-str_256">Str_256.str_256</a>, <a href="Str_256/index.html#type-str_256">Str_256.str_256</a>, Bin_prot.Common.buf)</span> <a href="Marshal_factory/index.html#type-kv_mshlr">Marshal_factory.kv_mshlr</a></span>; &gt;; for_s256 : <span><span>(<a href="Str_256/index.html#type-str_256">Str_256.str_256</a>, Bin_prot.Common.buf)</span> <a href="Marshal_factory/index.html#type-mshlr">Marshal_factory.mshlr</a></span>; &gt;</code></dt></dl></section><section><header><h3 id="marshalling-with-bin-prot"><a href="#marshalling-with-bin-prot" class="anchor"></a>Marshalling with bin-prot</h3></header><div class="spec module" id="module-Pvt_bin_prot_marshalling"><a href="#module-Pvt_bin_prot_marshalling" class="anchor"></a><code><span class="keyword">module</span> Pvt_bin_prot_marshalling = <a href="../Tjr_fs_shared__/index.html#module-Bin_prot_marshalling">Tjr_fs_shared__.Bin_prot_marshalling</a></code></div><dl><dt class="spec type" id="type-bp_mshlr"><a href="#type-bp_mshlr" class="anchor"></a><code><span class="keyword">type</span> <span>'a bp_mshlr</span></code><code> = <span><span class="type-var">'a</span> <a href="../Tjr_fs_shared__/Bin_prot_marshalling/index.html#type-bp_mshlr">Pvt_bin_prot_marshalling.bp_mshlr</a></span></code></dt><dt class="spec type" id="type-ba_mshlr"><a href="#type-ba_mshlr" class="anchor"></a><code><span class="keyword">type</span> <span>'a ba_mshlr</span></code><code> = <span><span class="type-var">'a</span> <a href="../Tjr_fs_shared__/Bin_prot_marshalling/index.html#type-ba_mshlr">Pvt_bin_prot_marshalling.ba_mshlr</a></span></code></dt></dl><dl><dt class="spec value" id="val-bp_mshlrs"><a href="#val-bp_mshlrs" class="anchor"></a><code><span class="keyword">val</span> bp_mshlrs : &lt; ba_mshlr : a. <span>mshlr:<span><span class="type-var">'a</span> <a href="../Tjr_fs_shared__/Bin_prot_marshalling/index.html#type-bp_mshlr">Pvt_bin_prot_marshalling.bp_mshlr</a></span></span> <span>&#45;&gt;</span> <span>buf_sz:int</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Tjr_fs_shared__/Bin_prot_marshalling/index.html#type-ba_mshlr">Pvt_bin_prot_marshalling.ba_mshlr</a></span>; int_mshlr : <span>int <a href="../Tjr_fs_shared__/Bin_prot_marshalling/index.html#type-bp_mshlr">Pvt_bin_prot_marshalling.bp_mshlr</a></span>; r_mshlr : <span><a href="Shared_ctxt/index.html#type-r">Shared_ctxt.r</a> <a href="../Tjr_fs_shared__/Bin_prot_marshalling/index.html#type-bp_mshlr">Pvt_bin_prot_marshalling.bp_mshlr</a></span>; s256_mshlr : <span><a href="Str_256/index.html#type-str_256">Str_256.str_256</a> <a href="../Tjr_fs_shared__/Bin_prot_marshalling/index.html#type-bp_mshlr">Pvt_bin_prot_marshalling.bp_mshlr</a></span>; &gt;</code></dt></dl></section><section><header><h3 id="standard-example-types-and-defns"><a href="#standard-example-types-and-defns" class="anchor"></a>Standard example types and defns</h3></header><dl><dt class="spec module" id="module-Shared_ctxt"><a href="#module-Shared_ctxt" class="anchor"></a><code><span class="keyword">module</span> <a href="Shared_ctxt/index.html">Shared_ctxt</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Represent common context using classes; don't open (use <code>Tjr_fs_shared.ctxt#shared</code>)</p></dd></dl><dl><dt class="spec value" id="val-ctxt"><a href="#val-ctxt" class="anchor"></a><code><span class="keyword">val</span> ctxt : &lt; shared_ctxt : <span><span>(<a href="Shared_ctxt/index.html#type-r">Shared_ctxt.r</a>, <a href="Buf_ops/index.html#type-ba_buf">Buf_ops.ba_buf</a>, Bigstring.t, Tjr_monad.With_lwt.lwt)</span> <a href="Shared_ctxt/index.html#type-shared_ctxt">Shared_ctxt.shared_ctxt</a></span>; &gt;</code></dt></dl></section><section><header><h3 id="testing"><a href="#testing" class="anchor"></a>Testing</h3></header><dl><dt class="spec module" id="module-Test"><a href="#module-Test" class="anchor"></a><code><span class="keyword">module</span> <a href="Test/index.html">Test</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Support for basic testing, controlled by optcomp</p></dd></dl></section><section><header><h3 id="log"><a href="#log" class="anchor"></a>Log</h3></header><div class="spec module" id="module-Log"><a href="#module-Log" class="anchor"></a><code><span class="keyword">module</span> <a href="Log/index.html">Log</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h3 id="runtime-config-support"><a href="#runtime-config-support" class="anchor"></a>Runtime config support</h3></header><dl><dt class="spec value" id="val-runtime_config_factory"><a href="#val-runtime_config_factory" class="anchor"></a><code><span class="keyword">val</span> runtime_config_factory : &lt; make : <span>default:<span><span class="type-var">'a</span> option</span></span> <span>&#45;&gt;</span> <span>filename:string</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Tjr_fs_shared__/Runtime_config_factory/index.html#type-runtime_config">Tjr_fs_shared__.Runtime_config_factory.runtime_config</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Stdlib.Lazy.t</span>; &gt;</code></dt></dl></section></div></body></html>