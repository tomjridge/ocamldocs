<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Tjr_plist (tjr_plist.Tjr_plist)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">tjr_plist</a> &#x00BB; Tjr_plist</nav><h1>Module <code>Tjr_plist</code></h1><p>A persistent (on-disk) list.</p>
<img width='100%' src="https://docs.google.com/drawings/d/e/2PACX-1vT1LGM8Sm7USD8LF_CGLUVZ270PK4vk5LcBrENxjcebpRUYq4jxPpgCTzNFsIS8TOgrcsVvcbZcNJ-M/pub?w=974&amp;h=871">
<p>Look at <a href="Plist_intf/index.html"><code>Plist_intf</code></a> for the main types.</p><p>Sync behaviour: There are at least 3 choices (in addition to respecting explicit syncs):</p><ul><li>sync on every add</li></ul><ul><li>sync on moving to a new tl; if we assume the blk_dev respects write order, we don't need to sync of course (we initialize new blk, write old blk with pointer, and advance to new); but this doesn't guarantee the writes are on the disk (just that the on-disk structure is consistent with some prior state)</li></ul><p>The point of the plist is that we can move to a new tl blk without necessarily rewriting any pointers outside the 2 plist tl blocks, but the price is that we have to traverse the entire list when we recover.</p><p>For the cost of one extra block write (for 3 synchronized block writes), we can sync the plist root block as well (ie the block that record hd, tl and len).</p><p>The freelist goes a step further to try to minimize costly disk interaction: it maintains a set of free blks, and only when these get low does it (asynchronously) try to replenish from disk. The cost of this is that a crash will result in some orphaned/lost blocks that can only be recovered by an fsck-like scan or some other mechanism. However, the assumption is that crashes are rare, and that the blk device is large enough that some lost blocks are not too much of an issue.</p></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Tjr_plist__/index.html#module-Summary">Tjr_plist__.Summary</a></code></span></summary><aside><p>Summary of main types</p></aside><aside><pre><code class="ml">type ('a,'blk_id,'blk,'buf,'t) plist_factory = &lt;
  monad_ops          :'t monad_ops;
  buf_ops            :'buf buf_ops;
  blk_ops            : 'blk blk_ops;
  plist_marshal_info : ('a,'blk_id,'blk,'buf) plist_marshal_info;
  plist_marshal_ops  : ('a,'blk_id,'blk) plist_marshal_ops; 
  with_blk_dev_ops   :  
    blk_dev_ops : ('blk_id,'blk,'t)blk_dev_ops 
    -&gt; &lt;
      blk_dev_ops     : ('blk_id,'blk,'t)blk_dev_ops;
      plist_extra_ops : ('a,'buf,'blk_id,'t) plist_extra_ops;
      with_state      : (('blk_id,'buf)plist,'t)with_state -&gt; 
        ('a,'buf,'blk_id,'t)plist_ops;
      from_disk       : &lt;hd:'blk_id;tl:'blk_id;blk_len:int&gt; -&gt; 
        (&lt;
          plist_ops:('a,'buf,'blk_id,'t)plist_ops;
          with_plist: (('blk_id,'buf)plist,'t)with_state;
          plist_ref: ('blk_id,'buf)plist ref;              
        &gt;,'t)m
    &gt;
&gt;

type ('a,'buf (* FIXME *),'blk_id,(* 'blk,*) 't) plist_ops = {
  add       : nxt:'blk_id -&gt; elt:'a -&gt; ('blk_id option,'t) m;
  add_if_room: 'a -&gt; (bool,'t)m;
  sync_tl   : unit -&gt; (unit,'t)m;
  blk_len   : unit -&gt; (int,'t)m;
  adv_hd    : unit -&gt; ( ('a,'blk_id) adv_hd or_error,'t)m; 
  (** advance hd *)

  adv_tl    : 'blk_id -&gt; (unit,'t)m;
  get_hd    : unit -&gt; ('blk_id,'t)m;
  get_tl    : unit -&gt; ('blk_id,'t)m;
  get_hd_tl : unit -&gt; ('blk_id * 'blk_id,'t)m;
  read_hd   : unit -&gt; ('a list * 'blk_id option,'t)m;
  append    : ('blk_id,'buf) plist -&gt; (unit,'t)m;
  (* read_tl   : unit -&gt; (('a list * 'blk_id option)or_error,'t)m; *)
  (* read_blk  : 'blk_id -&gt; (('a list * 'blk_id option)or_error,'t)m *)
}</code></pre></aside></details></div></div></div><dl><dt class="spec module" id="module-Plist_intf"><a href="#module-Plist_intf" class="anchor"></a><code><span class="keyword">module</span> <a href="Plist_intf/index.html">Plist_intf</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Plist main types</p></dd></dl><dl><dt class="spec module" id="module-Plist_sync_root_blk"><a href="#module-Plist_sync_root_blk" class="anchor"></a><code><span class="keyword">module</span> <a href="Plist_sync_root_blk/index.html">Plist_sync_root_blk</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Utility module, for adding sync when hd,tl ptrs change</p></dd></dl><aside><p>NOTE hidden doc for <code>Make_1</code></p></aside><dl><dt class="spec module" id="module-Make_5"><a href="#module-Make_5" class="anchor"></a><code><span class="keyword">module</span> <a href="Make_5/index.html">Make_5</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Like <code>Make_1</code>, but outputs only a plist_factory; this is the preferred intf</p></dd></dl><dl><dt class="spec value" id="val-pl_examples"><a href="#val-pl_examples" class="anchor"></a><code><span class="keyword">val</span> pl_examples : &lt; int_plist_factory : <span>int <a href="Pl_type_abbrevs/index.html#type-plist_factory">Pl_type_abbrevs.plist_factory</a></span>; &gt;</code></dt></dl><aside><p>NOTE hidden doc for module <code>Pl_type_abbrevs</code></p></aside></div></body></html>